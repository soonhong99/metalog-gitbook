# 기술 스택

## 1. Backend Core

### Spring Boot (Java 17)

* **선택 이유**:
  * 강력한 엔터프라이스 지원과 광범위한 생태계
  * 마이크로서비스 아키텍처 구현에 최적화
  * Spring Cloud와의 완벽한 통합으로 MSA 구현 용이
  * 높은 성능과 안정성 보장
  * 자동화된 테스트 지원과 풍부한 개발 도구

### Node.js (실시간 처리 서비스)

* **선택 이유**:
  * 실시간 데이터 처리에 최적화된 이벤트 기반 아키텍처
  * 비동기 I/O 처리로 높은 동시성 처리 가능
  * WebSocket을 통한 실시간 알림 구현에 적합
  * 가벼운 마이크로서비스 구현에 효율적

***

## 2. Database

### PostgreSQL

* **선택 이유**:
  * 강력한 ACID 준수로 데이터 정합성 보장
  * 사용자 정보, 관계 데이터 관리에 적합
  * JSON 타입 지원으로 유연한 데이터 구조 가능
  * 대용량 데이터 처리에 대한 높은 신뢰성

### MongoDB

* **선택 이유**:
  * 유연한 스키마로 다양한 메타 데이터 저장에 적합
  * 수평적 확장이 용이한 분산 데이터베이스
  * 게시물, 방 커스터마이징 데이터 같은 비정형 데이터 처리에 최적화
  * 높은 쓰기 성능으로 실시간 데이터 처리에 적합

### Redis

* **선택 이유**:
  * 고성능 인메모리 캐싱으로 빠른 데이터 접근
  * 세션 관리 및 실시간 랭킹 데이터 처리에 적합
  * Pub/Sub 기능을 통한 실시간 메시지 처리
  * 분산 캐싱으로 시스템 확장성 지원

***

## 3. Message Queue

### Apache Kafka

* **선택 이유**:
  * 대용량 실시간 로그 처리에 최적화
  * 높은 처리량과 낮은 지연시간
  * 이벤트 기반 아키텍처 구현에 적합
  * 데이터 파이프라인 구축의 표준

***

## 4. Infrastructure

### Docker

* **선택 이유**:
  * 일관된 개발/운영 환경 제공
  * 마이크로서비스 배포 관리 용이
  * 컨테이너화를 통한 리소스 효율적 사용
  * CI/CD 파이프라인 통합 용이

### Kubernetes

* **선택 이유**:
  * 컨테이너 오케스트레이션의 산업 표준
  * 자동화된 배포, 스케일링, 운영
  * 서비스 디스커버리와 로드 밸런싱
  * 무중단 배포 지원

***

## 5. Frontend

### React

* **선택 이유**:
  * 컴포넌트 기반 아키텍처로 재사용성 높음
  * Virtual DOM을 통한 효율적인 렌더링
  * 풍부한 생태계와 커뮤니티 지원
  * 메타 에셋 렌더링에 적합한 성능

***

## 6. API Design

### GraphQL

* **선택 이유**:
  * 클라이언트 중심의 유연한 데이터 쿼리
  * 오버페칭/언더페칭 문제 해결
  * 실시간 데이터 구독 기능 지원
  * API 버전 관리 부담 감소

### REST API

* **선택 이유**:
  * 표준화된 인터페이스로 높은 호환성
  * 캐시 활용이 용이
  * 간단한 CRUD 작업에 효율적
  * 마이크로서비스 간 통신 표준

***

## 7. Monitoring & Logging

### ELK Stack

* **선택 이유**:
  * 실시간 로그 수집 및 분석
  * 분산 시스템 모니터링에 적합
  * 강력한 검색과 시각화 기능
  * 대규모 로그 처리에 최적화

### Prometheus + Grafana

* **선택 이유**:
  * 컨테이너 환경 모니터링에 최적화
  * 시계열 데이터 처리에 특화
  * 알림 설정 및 관리 용이
  * 직관적인 대시보드 제공

***

## 8. Testing

#### JUnit 5 + Mockito

* **선택 이유**:
  * Java 생태계의 표준 테스트 프레임워크
  * 풍부한 테스트 기능과 확장성
  * 모킹을 통한 격리된 단위 테스트 가능
  * Spring Boot와의 완벽한 통합
